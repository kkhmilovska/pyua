# (PART\*) Функції {-}

# Функції {#functions}

Про фунцкії ми вже говорили у Главі \@ref(vars). Тоді ми визначили функції, як маленькі програми або набір інструкцій, який вирішував ту чи іншу проблему. Ми також використовували вже багато різноманітних вбудованих фунцкцій -- `abs()` для знаходження модуля числа, `max()` для знаходження максимума серед елементів списку, `len()` для знаходження кількості елементів тощо.

### Визначаємо фунцкії

Такі фунцкії як `abs()`, `len()` тощо називаються "вбудованими" у Python функціями. Код для цих фунцкій написали розробники мови Python і ми можемо їх зразу використовувати. Те що ми не знаємо з яких саме інструкції ці фунцкії складються та як саме вони працюють -- не проблема. Ми використовуємо такі фунцкії як так звані "чорні скриньки" -- ми знаємо вхідні дані (аргументи) та що очікувати на виході, але не механізм всередині.

<!-- XXX: example of black box -->

Ми можемо подивитись на такі фунцкії з математичної точки зору. Функція -- це те що ми по-простому називаємо формулою. Наприклад формула площі круга з радіусом $r$ є $s = \pi * r^2$. У цій формулі вхідними даними є радіус `r` і вона поверне площу, тобто `s`.

<!-- XXX: examples of areas of squre, circlt, etc. -->

Часто нам доведеться створювати наші власні фунцкії. Правильно називати їх -- user-defined functions або функції, визначенні користувачем. Ми будемо використовувати скорочену версію -- просто функції. Для того щоб побудувати фунцкію, нам треба чітко знати вхідні дані, алгоритм фунції та вихідні дані -- те, що фунцкія поверне.

Давайте побудуємо фунцкію, яка розрахує площу трикутника, використовуючи довжини його сторін. Ці довжини ми позначимо буквами `a`, `b` та `c`. Це й будуть вхідні дані. Коли ми визначаємо фунцкію, вхідні дані ми називаємо параметрами фунцкії. Функція повинна повернути значення площі трикутника -- це вихідні дані. 

<!-- XXX: example of triangle function-->

Тепер поговоримо про тіло фунцкії -- ті інструцкії, які реалізують алгоритм або логіку фунцкії. Для того щоб нам обчислити площу трикутнику за трьома сторонами, нам треба скористатись формулою Герона. Якщо чесно, то автор цієї книги її не пам'ятав, тому подивився у Вікіпедії. Для того, щоб її використати, нам спершу треба знайти пів-периметр за формулою: 

$$
p = \frac{a + b + c}{2}
$$

Далі, площа трикутника за формулою Герона буде:

$$
s = \sqrt{p(p - a)(p - b)(p - c)}
$$
Наша фунцкія буде виглядати: 

```{python}
def compute_area(a, b, c):
    p = (a + b + c) / 2
    s = (p * (p - a) * (p - b) * (p - c)) ** 0.5
    return s
```

Давайте подивимось на які частини це визначення фунцкії поділяється: 

* `def`: ключове слово, яке свідчить про те, що далі буде визначення фунцкії
* `compute_area`: ім'я фунцкії, яке може бути будь-яким дійсним ім'ям 
* `(a, b, c)`: параметри функції, перелічені через кому
* `:`: двокрапка, що позначає початок блоку коду
* рядки `p = (a + b + c) / 2`, `s = (p * (p - a) * (p - b) * (p - c)) ** 0.5` та `return s`: тіло функції
* `return`: ключове слово що зазначає об'єкт, який буде повернений

Параметри функції `a`, `b` та `c` -- це ті змінні, які ми будемо використовувати всередині фунцкії. Від параметрів взагалі кажуче й буде залежити те, що фунцкія буде робити та  те, що вона поверне. Коли ми вже працюємо всередині фунцкії, тобто всередині її тіла, ми можемо думати що параметри -- це звичайні змінні.

Після того, як функція написана, цей код треба виконати. Це не означає що ми використали цю фунцкію, ми тільки її визначили. Іншими словами, ми надали Python рецепт як приготувати борщ, але ми ще не почали його готувати. Грубо кажучи, ми присвоїли набір інструкцій до імені `compute_area()`, але не виконали їх. Тепер фунцкія знаходиться у пам'яті Python і ми можемо її використати у будь-який час. Процес використання фунцкії називається викликати фунцкію.

## Викликаємо фунцкію

Для того щоб викликати фунцкію, достатньо зазначити її ім'я та зазначити у дужках аргументи фунцкії, якщо цього вимагає фунцкія. Коли ми визначаємо функцію, `a`, `b` та `c` називаються параметрами, а ось коли ми викликаємо фунцкію, вони вже називаються аргументами. Давайте виклечемо фунцуію `compute_area()`: 

```{python}
compute_area(3, 4, 5)
```

Коли ми викликали фунцкію, це означає що Python почав виконувати інструкції з тіла фунцкії. При чому параметри функції `a`, `b` та `c` прйняли значення `3`, `4` та `5`, відповідно. 

<!-- XXX: the way Python interpreter moved to the place where the function is defined -->

До речі, порядок розташування клітинок у Google Colab в якої міститься визначення функції та з якої ми її визиваємо не має значення. Має значення тільки порядок за яким ми їх викликаємо -- спершу ми повинні виконати клітину з визначенням фунцкії, і тільки потім ми можемо викликати цю функцію. 

### Позиційні аргументи

Як Python здогадався, що коли ми викликали `compute_area(3, 4, 5)`, саме `a` дорівнювало `3`, `b` -- `4`, а `c` -- `5`? Це тому що порядок за яким ми задали значення `3`, `4` та `5` співпадав з порядком параметрів `a`, `b` та `c` у визначенні. Такий спосіб задання 

### Ключові аргументи 

## Параметри за замовчуванням


Чому ми використовуємо фунцкії? По-перше, ми можемо використовувати фунцкії як чорні коробки". Є вхідні дані, якийсь механізм в середині, і є вихідні дані. 





Ми не знаємо з яких саме інструкцій ці фунцкії складаються, і все що нам треба знати -- це які аргументи фунцкція приймає (якщо це передбаченно) та які об'єкти вона повертає (якщо це передбаченно). Аргументи фунцкії -- це об'єкт котрі ми передаємо у фунцкію, які вона потім використовує в своїх інструкціях. Ми можемо сприймати аргументи -- як вхідні дані. Щоб викликати фунцкію, нам треба зазначити її ім'я та перелічити аргументи у дужках після імені фунцкції. 

```{python}
# ?max
```

```{python}
# def f(qty, item, price):
#     print(f'{qty} {item} cost ${price:.2f}')
# 
# f(price = 5, item = "a", qty = 2)
```

```{python}
# print(range(1, 10,  2))
```

## Навіщо нам потрібні фунцкії

### Do not repeat yourself 

```{python}
# floors = ["1  ", " 3", "roof", " 3 ", "3", "2"]
# 
# for i, e in enumerate(floors):
#     floors[i] = floors[i].strip()
#     
#     if floors[i] == "roof":
#         floors[i] = "4"
#     
#     if floors[i].isnumeric():
#         floors[i] = int(floors[i])
# 
# floors
```

